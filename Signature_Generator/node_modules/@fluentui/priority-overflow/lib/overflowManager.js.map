{"version":3,"sources":["overflowManager.ts"],"sourcesContent":["import { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { debounce } from './debounce';\nimport { createPriorityQueue, PriorityQueue } from './priorityQueue';\nimport type {\n  OverflowGroupState,\n  OverflowItemEntry,\n  OverflowManager,\n  ObserveOptions,\n  OverflowDividerEntry,\n} from './types';\n\n/**\n * @internal\n * @returns overflow manager instance\n */\nexport function createOverflowManager(): OverflowManager {\n  // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n  // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n  const sizeCache = new Map<HTMLElement, number>();\n  let container: HTMLElement | undefined;\n  let overflowMenu: HTMLElement | undefined;\n  // Set as true when resize observer is observing\n  let observing = false;\n  // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n  // Initially true to force dispatch on first mount\n  let forceDispatch = true;\n  const options: Required<ObserveOptions> = {\n    padding: 10,\n    overflowAxis: 'horizontal',\n    overflowDirection: 'end',\n    minimumVisible: 0,\n    onUpdateItemVisibility: () => undefined,\n    onUpdateOverflow: () => undefined,\n  };\n\n  const overflowItems: Record<string, OverflowItemEntry> = {};\n  const overflowDividers: Record<string, OverflowDividerEntry> = {};\n  const resizeObserver = new ResizeObserver(entries => {\n    if (!entries[0] || !container) {\n      return;\n    }\n\n    update();\n  });\n\n  const getNextItem = (queueToDequeue: PriorityQueue<string>, queueToEnqueue: PriorityQueue<string>) => {\n    const nextItem = queueToDequeue.dequeue();\n    queueToEnqueue.enqueue(nextItem);\n    return overflowItems[nextItem];\n  };\n\n  const createGroupManager = () => {\n    const groupVisibility: Record<string, OverflowGroupState> = {};\n    const groups: Record<string, { visibleItemIds: Set<string>; invisibleItemIds: Set<string> }> = {};\n    function updateGroupVisibility(groupId: string) {\n      const group = groups[groupId];\n      if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n        groupVisibility[groupId] = 'overflow';\n      } else if (group.visibleItemIds.size === 0) {\n        groupVisibility[groupId] = 'hidden';\n      } else {\n        groupVisibility[groupId] = 'visible';\n      }\n    }\n    function isGroupVisible(groupId: string) {\n      return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n    }\n    return {\n      groupVisibility: () => groupVisibility,\n      isSingleItemVisible(itemId: string, groupId: string) {\n        return (\n          isGroupVisible(groupId) &&\n          groups[groupId].visibleItemIds.has(itemId) &&\n          groups[groupId].visibleItemIds.size === 1\n        );\n      },\n      addItem(itemId: string, groupId: string) {\n        groups[groupId] ??= {\n          visibleItemIds: new Set<string>(),\n          invisibleItemIds: new Set<string>(),\n        };\n\n        groups[groupId].visibleItemIds.add(itemId);\n        updateGroupVisibility(groupId);\n      },\n      removeItem(itemId: string, groupId: string) {\n        groups[groupId].invisibleItemIds.delete(itemId);\n        groups[groupId].visibleItemIds.delete(itemId);\n        updateGroupVisibility(groupId);\n      },\n      showItem(itemId: string, groupId: string) {\n        groups[groupId].invisibleItemIds.delete(itemId);\n        groups[groupId].visibleItemIds.add(itemId);\n        updateGroupVisibility(groupId);\n      },\n      hideItem(itemId: string, groupId: string) {\n        groups[groupId].invisibleItemIds.add(itemId);\n        groups[groupId].visibleItemIds.delete(itemId);\n        updateGroupVisibility(groupId);\n      },\n    };\n  };\n\n  const groupManager = createGroupManager();\n\n  function compareItems(lt: string | null, rt: string | null): number {\n    if (!lt || !rt) {\n      return 0;\n    }\n\n    const lte = overflowItems[lt];\n    const rte = overflowItems[rt];\n\n    if (lte.priority !== rte.priority) {\n      return lte.priority > rte.priority ? 1 : -1;\n    }\n\n    const positionStatusBit =\n      options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n\n    // eslint-disable-next-line no-bitwise\n    return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;\n  }\n\n  function getElementAxisSize(\n    horizontal: 'clientWidth' | 'offsetWidth',\n    vertical: 'clientHeight' | 'offsetHeight',\n    el: HTMLElement,\n  ): number {\n    if (!sizeCache.has(el)) {\n      sizeCache.set(el, options.overflowAxis === 'horizontal' ? el[horizontal] : el[vertical]);\n    }\n\n    return sizeCache.get(el)!;\n  }\n\n  const getOffsetSize = getElementAxisSize.bind(null, 'offsetWidth', 'offsetHeight');\n  const getClientSize = getElementAxisSize.bind(null, 'clientWidth', 'clientHeight');\n\n  const invisibleItemQueue = createPriorityQueue<string>((a, b) => -1 * compareItems(a, b));\n\n  const visibleItemQueue = createPriorityQueue<string>(compareItems);\n\n  function occupiedSize(): number {\n    const totalItemSize = visibleItemQueue\n      .all()\n      .map(id => overflowItems[id].element)\n      .map(getOffsetSize)\n      .reduce((prev, current) => prev + current, 0);\n\n    const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce(\n      (acc, [id, state]) =>\n        acc + (state !== 'hidden' && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0),\n      0,\n    );\n\n    const overflowMenuSize = invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n\n    return totalItemSize + totalDividerSize + overflowMenuSize;\n  }\n\n  const showItem = () => {\n    const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n    options.onUpdateItemVisibility({ item, visible: true });\n\n    if (item.groupId) {\n      groupManager.showItem(item.id, item.groupId);\n\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        overflowDividers[item.groupId]?.element.removeAttribute(DATA_OVERFLOWING);\n      }\n    }\n  };\n\n  const hideItem = () => {\n    const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n    options.onUpdateItemVisibility({ item, visible: false });\n\n    if (item.groupId) {\n      if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n        overflowDividers[item.groupId]?.element.setAttribute(DATA_OVERFLOWING, '');\n      }\n\n      groupManager.hideItem(item.id, item.groupId);\n    }\n  };\n\n  const dispatchOverflowUpdate = () => {\n    const visibleItemIds = visibleItemQueue.all();\n    const invisibleItemIds = invisibleItemQueue.all();\n\n    const visibleItems = visibleItemIds.map(itemId => overflowItems[itemId]);\n    const invisibleItems = invisibleItemIds.map(itemId => overflowItems[itemId]);\n\n    options.onUpdateOverflow({ visibleItems, invisibleItems, groupVisibility: groupManager.groupVisibility() });\n  };\n\n  const processOverflowItems = (): boolean => {\n    if (!container) {\n      return false;\n    }\n    sizeCache.clear();\n\n    const availableSize = getClientSize(container) - options.padding;\n\n    // Snapshot of the visible/invisible state to compare for updates\n    const visibleTop = visibleItemQueue.peek();\n    const invisibleTop = invisibleItemQueue.peek();\n\n    while (compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0) {\n      hideItem(); // hide elements whose priority become smaller than the highest priority of the hidden one\n    }\n\n    // Run the show/hide step twice - the first step might not be correct if\n    // it was triggered by a new item being added - new items are always visible by default.\n    for (let i = 0; i < 2; i++) {\n      // Add items until available width is filled - can result in overflow\n      while (\n        (occupiedSize() < availableSize && invisibleItemQueue.size() > 0) ||\n        invisibleItemQueue.size() === 1 // attempt to show the last invisible item hoping it's size does not exceed overflow menu size\n      ) {\n        showItem();\n      }\n\n      // Remove items until there's no more overflow\n      while (occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible) {\n        hideItem();\n      }\n    }\n\n    // only update when the state of visible/invisible items has changed\n    return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n  };\n\n  const forceUpdate: OverflowManager['forceUpdate'] = () => {\n    if (processOverflowItems() || forceDispatch) {\n      forceDispatch = false;\n      dispatchOverflowUpdate();\n    }\n  };\n\n  const update: OverflowManager['update'] = debounce(forceUpdate);\n\n  const observe: OverflowManager['observe'] = (observedContainer, userOptions) => {\n    Object.assign(options, userOptions);\n    observing = true;\n    Object.values(overflowItems).forEach(item => visibleItemQueue.enqueue(item.id));\n\n    container = observedContainer;\n    resizeObserver.observe(container);\n  };\n\n  const disconnect: OverflowManager['disconnect'] = () => {\n    observing = false;\n    sizeCache.clear();\n    resizeObserver.disconnect();\n  };\n\n  const addItem: OverflowManager['addItem'] = item => {\n    if (overflowItems[item.id]) {\n      return;\n    }\n\n    overflowItems[item.id] = item;\n\n    // some options can affect priority which are only set on `observe`\n    if (observing) {\n      // Updates to elements might not change the queue tops\n      // i.e. new element is enqueued but the top of the queue stays the same\n      // force a dispatch on the next batched update\n      forceDispatch = true;\n      visibleItemQueue.enqueue(item.id);\n    }\n\n    if (item.groupId) {\n      groupManager.addItem(item.id, item.groupId);\n      item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n    }\n\n    update();\n  };\n\n  const addOverflowMenu: OverflowManager['addOverflowMenu'] = el => {\n    overflowMenu = el;\n  };\n\n  const addDivider: OverflowManager['addDivider'] = divider => {\n    if (!divider.groupId || overflowDividers[divider.groupId]) {\n      return;\n    }\n\n    divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n    overflowDividers[divider.groupId] = divider;\n  };\n\n  const removeOverflowMenu: OverflowManager['removeOverflowMenu'] = () => {\n    overflowMenu = undefined;\n  };\n\n  const removeDivider: OverflowManager['removeDivider'] = groupId => {\n    if (!overflowDividers[groupId]) {\n      return;\n    }\n    const divider = overflowDividers[groupId];\n    if (divider.groupId) {\n      delete overflowDividers[groupId];\n      divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n  };\n\n  const removeItem: OverflowManager['removeItem'] = itemId => {\n    if (!overflowItems[itemId]) {\n      return;\n    }\n\n    const item = overflowItems[itemId];\n    visibleItemQueue.remove(itemId);\n    invisibleItemQueue.remove(itemId);\n\n    if (item.groupId) {\n      groupManager.removeItem(item.id, item.groupId);\n      item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n    }\n\n    sizeCache.delete(item.element);\n    delete overflowItems[itemId];\n    update();\n  };\n\n  return {\n    addItem,\n    disconnect,\n    forceUpdate,\n    observe,\n    removeItem,\n    update,\n    addOverflowMenu,\n    removeOverflowMenu,\n    addDivider,\n    removeDivider,\n  };\n}\n"],"names":["DATA_OVERFLOWING","DATA_OVERFLOW_GROUP","debounce","createPriorityQueue","createOverflowManager","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowDividers","resizeObserver","ResizeObserver","entries","update","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","createGroupManager","groupVisibility","groups","updateGroupVisibility","groupId","group","invisibleItemIds","size","visibleItemIds","isGroupVisible","isSingleItemVisible","itemId","has","addItem","Set","add","removeItem","delete","showItem","hideItem","groupManager","compareItems","lt","rt","lte","rte","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","getElementAxisSize","horizontal","vertical","el","set","get","getOffsetSize","bind","getClientSize","invisibleItemQueue","a","b","visibleItemQueue","occupiedSize","totalItemSize","all","map","id","reduce","prev","current","totalDividerSize","Object","acc","state","overflowMenuSize","item","visible","removeAttribute","setAttribute","dispatchOverflowUpdate","visibleItems","invisibleItems","processOverflowItems","clear","availableSize","visibleTop","peek","invisibleTop","i","forceUpdate","observe","observedContainer","userOptions","assign","values","forEach","disconnect","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","remove"],"mappings":"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"}