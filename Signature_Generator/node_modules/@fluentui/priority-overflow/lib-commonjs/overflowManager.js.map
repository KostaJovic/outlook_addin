{"version":3,"sources":["overflowManager.js"],"sourcesContent":["import { DATA_OVERFLOWING, DATA_OVERFLOW_GROUP } from './consts';\nimport { debounce } from './debounce';\nimport { createPriorityQueue } from './priorityQueue';\n/**\n * @internal\n * @returns overflow manager instance\n */ export function createOverflowManager() {\n    // calls to `offsetWidth or offsetHeight` can happen multiple times in an update\n    // Use a cache to avoid causing too many recalcs and avoid scripting time to meausure sizes\n    const sizeCache = new Map();\n    let container;\n    let overflowMenu;\n    // Set as true when resize observer is observing\n    let observing = false;\n    // If true, next update will dispatch to onUpdateOverflow even if queue top states don't change\n    // Initially true to force dispatch on first mount\n    let forceDispatch = true;\n    const options = {\n        padding: 10,\n        overflowAxis: 'horizontal',\n        overflowDirection: 'end',\n        minimumVisible: 0,\n        onUpdateItemVisibility: ()=>undefined,\n        onUpdateOverflow: ()=>undefined\n    };\n    const overflowItems = {};\n    const overflowDividers = {};\n    const resizeObserver = new ResizeObserver((entries)=>{\n        if (!entries[0] || !container) {\n            return;\n        }\n        update();\n    });\n    const getNextItem = (queueToDequeue, queueToEnqueue)=>{\n        const nextItem = queueToDequeue.dequeue();\n        queueToEnqueue.enqueue(nextItem);\n        return overflowItems[nextItem];\n    };\n    const createGroupManager = ()=>{\n        const groupVisibility = {};\n        const groups = {};\n        function updateGroupVisibility(groupId) {\n            const group = groups[groupId];\n            if (group.invisibleItemIds.size && group.visibleItemIds.size) {\n                groupVisibility[groupId] = 'overflow';\n            } else if (group.visibleItemIds.size === 0) {\n                groupVisibility[groupId] = 'hidden';\n            } else {\n                groupVisibility[groupId] = 'visible';\n            }\n        }\n        function isGroupVisible(groupId) {\n            return groupVisibility[groupId] === 'visible' || groupVisibility[groupId] === 'overflow';\n        }\n        return {\n            groupVisibility: ()=>groupVisibility,\n            isSingleItemVisible (itemId, groupId) {\n                return isGroupVisible(groupId) && groups[groupId].visibleItemIds.has(itemId) && groups[groupId].visibleItemIds.size === 1;\n            },\n            addItem (itemId, groupId) {\n                var _groups, _groupId;\n                var _;\n                (_ = (_groups = groups)[_groupId = groupId]) !== null && _ !== void 0 ? _ : _groups[_groupId] = {\n                    visibleItemIds: new Set(),\n                    invisibleItemIds: new Set()\n                };\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            removeItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            },\n            showItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.delete(itemId);\n                groups[groupId].visibleItemIds.add(itemId);\n                updateGroupVisibility(groupId);\n            },\n            hideItem (itemId, groupId) {\n                groups[groupId].invisibleItemIds.add(itemId);\n                groups[groupId].visibleItemIds.delete(itemId);\n                updateGroupVisibility(groupId);\n            }\n        };\n    };\n    const groupManager = createGroupManager();\n    function compareItems(lt, rt) {\n        if (!lt || !rt) {\n            return 0;\n        }\n        const lte = overflowItems[lt];\n        const rte = overflowItems[rt];\n        if (lte.priority !== rte.priority) {\n            return lte.priority > rte.priority ? 1 : -1;\n        }\n        const positionStatusBit = options.overflowDirection === 'end' ? Node.DOCUMENT_POSITION_FOLLOWING : Node.DOCUMENT_POSITION_PRECEDING;\n        // eslint-disable-next-line no-bitwise\n        return lte.element.compareDocumentPosition(rte.element) & positionStatusBit ? 1 : -1;\n    }\n    function getElementAxisSize(horizontal, vertical, el) {\n        if (!sizeCache.has(el)) {\n            sizeCache.set(el, options.overflowAxis === 'horizontal' ? el[horizontal] : el[vertical]);\n        }\n        return sizeCache.get(el);\n    }\n    const getOffsetSize = getElementAxisSize.bind(null, 'offsetWidth', 'offsetHeight');\n    const getClientSize = getElementAxisSize.bind(null, 'clientWidth', 'clientHeight');\n    const invisibleItemQueue = createPriorityQueue((a, b)=>-1 * compareItems(a, b));\n    const visibleItemQueue = createPriorityQueue(compareItems);\n    function occupiedSize() {\n        const totalItemSize = visibleItemQueue.all().map((id)=>overflowItems[id].element).map(getOffsetSize).reduce((prev, current)=>prev + current, 0);\n        const totalDividerSize = Object.entries(groupManager.groupVisibility()).reduce((acc, [id, state])=>acc + (state !== 'hidden' && overflowDividers[id] ? getOffsetSize(overflowDividers[id].element) : 0), 0);\n        const overflowMenuSize = invisibleItemQueue.size() > 0 && overflowMenu ? getOffsetSize(overflowMenu) : 0;\n        return totalItemSize + totalDividerSize + overflowMenuSize;\n    }\n    const showItem = ()=>{\n        const item = getNextItem(invisibleItemQueue, visibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: true\n        });\n        if (item.groupId) {\n            groupManager.showItem(item.id, item.groupId);\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.removeAttribute(DATA_OVERFLOWING);\n            }\n        }\n    };\n    const hideItem = ()=>{\n        const item = getNextItem(visibleItemQueue, invisibleItemQueue);\n        options.onUpdateItemVisibility({\n            item,\n            visible: false\n        });\n        if (item.groupId) {\n            if (groupManager.isSingleItemVisible(item.id, item.groupId)) {\n                var _overflowDividers_item_groupId;\n                (_overflowDividers_item_groupId = overflowDividers[item.groupId]) === null || _overflowDividers_item_groupId === void 0 ? void 0 : _overflowDividers_item_groupId.element.setAttribute(DATA_OVERFLOWING, '');\n            }\n            groupManager.hideItem(item.id, item.groupId);\n        }\n    };\n    const dispatchOverflowUpdate = ()=>{\n        const visibleItemIds = visibleItemQueue.all();\n        const invisibleItemIds = invisibleItemQueue.all();\n        const visibleItems = visibleItemIds.map((itemId)=>overflowItems[itemId]);\n        const invisibleItems = invisibleItemIds.map((itemId)=>overflowItems[itemId]);\n        options.onUpdateOverflow({\n            visibleItems,\n            invisibleItems,\n            groupVisibility: groupManager.groupVisibility()\n        });\n    };\n    const processOverflowItems = ()=>{\n        if (!container) {\n            return false;\n        }\n        sizeCache.clear();\n        const availableSize = getClientSize(container) - options.padding;\n        // Snapshot of the visible/invisible state to compare for updates\n        const visibleTop = visibleItemQueue.peek();\n        const invisibleTop = invisibleItemQueue.peek();\n        while(compareItems(invisibleItemQueue.peek(), visibleItemQueue.peek()) > 0){\n            hideItem(); // hide elements whose priority become smaller than the highest priority of the hidden one\n        }\n        // Run the show/hide step twice - the first step might not be correct if\n        // it was triggered by a new item being added - new items are always visible by default.\n        for(let i = 0; i < 2; i++){\n            // Add items until available width is filled - can result in overflow\n            while(occupiedSize() < availableSize && invisibleItemQueue.size() > 0 || invisibleItemQueue.size() === 1 // attempt to show the last invisible item hoping it's size does not exceed overflow menu size\n            ){\n                showItem();\n            }\n            // Remove items until there's no more overflow\n            while(occupiedSize() > availableSize && visibleItemQueue.size() > options.minimumVisible){\n                hideItem();\n            }\n        }\n        // only update when the state of visible/invisible items has changed\n        return visibleItemQueue.peek() !== visibleTop || invisibleItemQueue.peek() !== invisibleTop;\n    };\n    const forceUpdate = ()=>{\n        if (processOverflowItems() || forceDispatch) {\n            forceDispatch = false;\n            dispatchOverflowUpdate();\n        }\n    };\n    const update = debounce(forceUpdate);\n    const observe = (observedContainer, userOptions)=>{\n        Object.assign(options, userOptions);\n        observing = true;\n        Object.values(overflowItems).forEach((item)=>visibleItemQueue.enqueue(item.id));\n        container = observedContainer;\n        resizeObserver.observe(container);\n    };\n    const disconnect = ()=>{\n        observing = false;\n        sizeCache.clear();\n        resizeObserver.disconnect();\n    };\n    const addItem = (item)=>{\n        if (overflowItems[item.id]) {\n            return;\n        }\n        overflowItems[item.id] = item;\n        // some options can affect priority which are only set on `observe`\n        if (observing) {\n            // Updates to elements might not change the queue tops\n            // i.e. new element is enqueued but the top of the queue stays the same\n            // force a dispatch on the next batched update\n            forceDispatch = true;\n            visibleItemQueue.enqueue(item.id);\n        }\n        if (item.groupId) {\n            groupManager.addItem(item.id, item.groupId);\n            item.element.setAttribute(DATA_OVERFLOW_GROUP, item.groupId);\n        }\n        update();\n    };\n    const addOverflowMenu = (el)=>{\n        overflowMenu = el;\n    };\n    const addDivider = (divider)=>{\n        if (!divider.groupId || overflowDividers[divider.groupId]) {\n            return;\n        }\n        divider.element.setAttribute(DATA_OVERFLOW_GROUP, divider.groupId);\n        overflowDividers[divider.groupId] = divider;\n    };\n    const removeOverflowMenu = ()=>{\n        overflowMenu = undefined;\n    };\n    const removeDivider = (groupId)=>{\n        if (!overflowDividers[groupId]) {\n            return;\n        }\n        const divider = overflowDividers[groupId];\n        if (divider.groupId) {\n            delete overflowDividers[groupId];\n            divider.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n    };\n    const removeItem = (itemId)=>{\n        if (!overflowItems[itemId]) {\n            return;\n        }\n        const item = overflowItems[itemId];\n        visibleItemQueue.remove(itemId);\n        invisibleItemQueue.remove(itemId);\n        if (item.groupId) {\n            groupManager.removeItem(item.id, item.groupId);\n            item.element.removeAttribute(DATA_OVERFLOW_GROUP);\n        }\n        sizeCache.delete(item.element);\n        delete overflowItems[itemId];\n        update();\n    };\n    return {\n        addItem,\n        disconnect,\n        forceUpdate,\n        observe,\n        removeItem,\n        update,\n        addOverflowMenu,\n        removeOverflowMenu,\n        addDivider,\n        removeDivider\n    };\n}\n"],"names":["createOverflowManager","sizeCache","Map","container","overflowMenu","observing","forceDispatch","options","padding","overflowAxis","overflowDirection","minimumVisible","onUpdateItemVisibility","undefined","onUpdateOverflow","overflowItems","overflowDividers","resizeObserver","ResizeObserver","entries","update","getNextItem","queueToDequeue","queueToEnqueue","nextItem","dequeue","enqueue","createGroupManager","groupVisibility","groups","updateGroupVisibility","groupId","group","invisibleItemIds","size","visibleItemIds","isGroupVisible","isSingleItemVisible","itemId","has","addItem","_groups","_groupId","_","Set","add","removeItem","delete","showItem","hideItem","groupManager","compareItems","lt","rt","lte","rte","priority","positionStatusBit","Node","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","element","compareDocumentPosition","getElementAxisSize","horizontal","vertical","el","set","get","getOffsetSize","bind","getClientSize","invisibleItemQueue","createPriorityQueue","a","b","visibleItemQueue","occupiedSize","totalItemSize","all","map","id","reduce","prev","current","totalDividerSize","Object","acc","state","overflowMenuSize","item","visible","_overflowDividers_item_groupId","removeAttribute","DATA_OVERFLOWING","setAttribute","dispatchOverflowUpdate","visibleItems","invisibleItems","processOverflowItems","clear","availableSize","visibleTop","peek","invisibleTop","i","forceUpdate","debounce","observe","observedContainer","userOptions","assign","values","forEach","disconnect","DATA_OVERFLOW_GROUP","addOverflowMenu","addDivider","divider","removeOverflowMenu","removeDivider","remove"],"mappings":";;;;+BAMoBA;;;eAAAA;;;wBANkC;0BAC7B;+BACW;AAIzB,SAASA;IAChB,gFAAgF;IAChF,2FAA2F;IAC3F,MAAMC,YAAY,IAAIC;IACtB,IAAIC;IACJ,IAAIC;IACJ,gDAAgD;IAChD,IAAIC,YAAY;IAChB,+FAA+F;IAC/F,kDAAkD;IAClD,IAAIC,gBAAgB;IACpB,MAAMC,UAAU;QACZC,SAAS;QACTC,cAAc;QACdC,mBAAmB;QACnBC,gBAAgB;QAChBC,wBAAwB,IAAIC;QAC5BC,kBAAkB,IAAID;IAC1B;IACA,MAAME,gBAAgB,CAAC;IACvB,MAAMC,mBAAmB,CAAC;IAC1B,MAAMC,iBAAiB,IAAIC,eAAe,CAACC;QACvC,IAAI,CAACA,OAAO,CAAC,EAAE,IAAI,CAAChB,WAAW;YAC3B;QACJ;QACAiB;IACJ;IACA,MAAMC,cAAc,CAACC,gBAAgBC;QACjC,MAAMC,WAAWF,eAAeG,OAAO;QACvCF,eAAeG,OAAO,CAACF;QACvB,OAAOT,aAAa,CAACS,SAAS;IAClC;IACA,MAAMG,qBAAqB;QACvB,MAAMC,kBAAkB,CAAC;QACzB,MAAMC,SAAS,CAAC;QAChB,SAASC,sBAAsBC,OAAO;YAClC,MAAMC,QAAQH,MAAM,CAACE,QAAQ;YAC7B,IAAIC,MAAMC,gBAAgB,CAACC,IAAI,IAAIF,MAAMG,cAAc,CAACD,IAAI,EAAE;gBAC1DN,eAAe,CAACG,QAAQ,GAAG;YAC/B,OAAO,IAAIC,MAAMG,cAAc,CAACD,IAAI,KAAK,GAAG;gBACxCN,eAAe,CAACG,QAAQ,GAAG;YAC/B,OAAO;gBACHH,eAAe,CAACG,QAAQ,GAAG;YAC/B;QACJ;QACA,SAASK,eAAeL,OAAO;YAC3B,OAAOH,eAAe,CAACG,QAAQ,KAAK,aAAaH,eAAe,CAACG,QAAQ,KAAK;QAClF;QACA,OAAO;YACHH,iBAAiB,IAAIA;YACrBS,qBAAqBC,MAAM,EAAEP,OAAO;gBAChC,OAAOK,eAAeL,YAAYF,MAAM,CAACE,QAAQ,CAACI,cAAc,CAACI,GAAG,CAACD,WAAWT,MAAM,CAACE,QAAQ,CAACI,cAAc,CAACD,IAAI,KAAK;YAC5H;YACAM,SAASF,MAAM,EAAEP,OAAO;gBACpB,IAAIU,SAASC;gBACb,IAAIC;gBACHA,CAAAA,IAAI,AAACF,CAAAA,UAAUZ,MAAK,CAAE,CAACa,WAAWX,QAAQ,AAAD,MAAO,QAAQY,MAAM,KAAK,IAAIA,IAAIF,OAAO,CAACC,SAAS,GAAG;oBAC5FP,gBAAgB,IAAIS;oBACpBX,kBAAkB,IAAIW;gBAC1B;gBACAf,MAAM,CAACE,QAAQ,CAACI,cAAc,CAACU,GAAG,CAACP;gBACnCR,sBAAsBC;YAC1B;YACAe,YAAYR,MAAM,EAAEP,OAAO;gBACvBF,MAAM,CAACE,QAAQ,CAACE,gBAAgB,CAACc,MAAM,CAACT;gBACxCT,MAAM,CAACE,QAAQ,CAACI,cAAc,CAACY,MAAM,CAACT;gBACtCR,sBAAsBC;YAC1B;YACAiB,UAAUV,MAAM,EAAEP,OAAO;gBACrBF,MAAM,CAACE,QAAQ,CAACE,gBAAgB,CAACc,MAAM,CAACT;gBACxCT,MAAM,CAACE,QAAQ,CAACI,cAAc,CAACU,GAAG,CAACP;gBACnCR,sBAAsBC;YAC1B;YACAkB,UAAUX,MAAM,EAAEP,OAAO;gBACrBF,MAAM,CAACE,QAAQ,CAACE,gBAAgB,CAACY,GAAG,CAACP;gBACrCT,MAAM,CAACE,QAAQ,CAACI,cAAc,CAACY,MAAM,CAACT;gBACtCR,sBAAsBC;YAC1B;QACJ;IACJ;IACA,MAAMmB,eAAevB;IACrB,SAASwB,aAAaC,EAAE,EAAEC,EAAE;QACxB,IAAI,CAACD,MAAM,CAACC,IAAI;YACZ,OAAO;QACX;QACA,MAAMC,MAAMvC,aAAa,CAACqC,GAAG;QAC7B,MAAMG,MAAMxC,aAAa,CAACsC,GAAG;QAC7B,IAAIC,IAAIE,QAAQ,KAAKD,IAAIC,QAAQ,EAAE;YAC/B,OAAOF,IAAIE,QAAQ,GAAGD,IAAIC,QAAQ,GAAG,IAAI,CAAC;QAC9C;QACA,MAAMC,oBAAoBlD,QAAQG,iBAAiB,KAAK,QAAQgD,KAAKC,2BAA2B,GAAGD,KAAKE,2BAA2B;QACnI,sCAAsC;QACtC,OAAON,IAAIO,OAAO,CAACC,uBAAuB,CAACP,IAAIM,OAAO,IAAIJ,oBAAoB,IAAI,CAAC;IACvF;IACA,SAASM,mBAAmBC,UAAU,EAAEC,QAAQ,EAAEC,EAAE;QAChD,IAAI,CAACjE,UAAUsC,GAAG,CAAC2B,KAAK;YACpBjE,UAAUkE,GAAG,CAACD,IAAI3D,QAAQE,YAAY,KAAK,eAAeyD,EAAE,CAACF,WAAW,GAAGE,EAAE,CAACD,SAAS;QAC3F;QACA,OAAOhE,UAAUmE,GAAG,CAACF;IACzB;IACA,MAAMG,gBAAgBN,mBAAmBO,IAAI,CAAC,MAAM,eAAe;IACnE,MAAMC,gBAAgBR,mBAAmBO,IAAI,CAAC,MAAM,eAAe;IACnE,MAAME,qBAAqBC,IAAAA,kCAAmB,EAAC,CAACC,GAAGC,IAAI,CAAC,IAAIxB,aAAauB,GAAGC;IAC5E,MAAMC,mBAAmBH,IAAAA,kCAAmB,EAACtB;IAC7C,SAAS0B;QACL,MAAMC,gBAAgBF,iBAAiBG,GAAG,GAAGC,GAAG,CAAC,CAACC,KAAKlE,aAAa,CAACkE,GAAG,CAACpB,OAAO,EAAEmB,GAAG,CAACX,eAAea,MAAM,CAAC,CAACC,MAAMC,UAAUD,OAAOC,SAAS;QAC7I,MAAMC,mBAAmBC,OAAOnE,OAAO,CAAC+B,aAAatB,eAAe,IAAIsD,MAAM,CAAC,CAACK,KAAK,CAACN,IAAIO,MAAM,GAAGD,MAAOC,CAAAA,UAAU,YAAYxE,gBAAgB,CAACiE,GAAG,GAAGZ,cAAcrD,gBAAgB,CAACiE,GAAG,CAACpB,OAAO,IAAI,CAAA,GAAI;QACzM,MAAM4B,mBAAmBjB,mBAAmBtC,IAAI,KAAK,KAAK9B,eAAeiE,cAAcjE,gBAAgB;QACvG,OAAO0E,gBAAgBO,mBAAmBI;IAC9C;IACA,MAAMzC,WAAW;QACb,MAAM0C,OAAOrE,YAAYmD,oBAAoBI;QAC7CrE,QAAQK,sBAAsB,CAAC;YAC3B8E;YACAC,SAAS;QACb;QACA,IAAID,KAAK3D,OAAO,EAAE;YACdmB,aAAaF,QAAQ,CAAC0C,KAAKT,EAAE,EAAES,KAAK3D,OAAO;YAC3C,IAAImB,aAAab,mBAAmB,CAACqD,KAAKT,EAAE,EAAES,KAAK3D,OAAO,GAAG;gBACzD,IAAI6D;gBACHA,CAAAA,iCAAiC5E,gBAAgB,CAAC0E,KAAK3D,OAAO,CAAC,AAAD,MAAO,QAAQ6D,mCAAmC,KAAK,IAAI,KAAK,IAAIA,+BAA+B/B,OAAO,CAACgC,eAAe,CAACC,wBAAgB;YAC9M;QACJ;IACJ;IACA,MAAM7C,WAAW;QACb,MAAMyC,OAAOrE,YAAYuD,kBAAkBJ;QAC3CjE,QAAQK,sBAAsB,CAAC;YAC3B8E;YACAC,SAAS;QACb;QACA,IAAID,KAAK3D,OAAO,EAAE;YACd,IAAImB,aAAab,mBAAmB,CAACqD,KAAKT,EAAE,EAAES,KAAK3D,OAAO,GAAG;gBACzD,IAAI6D;gBACHA,CAAAA,iCAAiC5E,gBAAgB,CAAC0E,KAAK3D,OAAO,CAAC,AAAD,MAAO,QAAQ6D,mCAAmC,KAAK,IAAI,KAAK,IAAIA,+BAA+B/B,OAAO,CAACkC,YAAY,CAACD,wBAAgB,EAAE;YAC7M;YACA5C,aAAaD,QAAQ,CAACyC,KAAKT,EAAE,EAAES,KAAK3D,OAAO;QAC/C;IACJ;IACA,MAAMiE,yBAAyB;QAC3B,MAAM7D,iBAAiByC,iBAAiBG,GAAG;QAC3C,MAAM9C,mBAAmBuC,mBAAmBO,GAAG;QAC/C,MAAMkB,eAAe9D,eAAe6C,GAAG,CAAC,CAAC1C,SAASvB,aAAa,CAACuB,OAAO;QACvE,MAAM4D,iBAAiBjE,iBAAiB+C,GAAG,CAAC,CAAC1C,SAASvB,aAAa,CAACuB,OAAO;QAC3E/B,QAAQO,gBAAgB,CAAC;YACrBmF;YACAC;YACAtE,iBAAiBsB,aAAatB,eAAe;QACjD;IACJ;IACA,MAAMuE,uBAAuB;QACzB,IAAI,CAAChG,WAAW;YACZ,OAAO;QACX;QACAF,UAAUmG,KAAK;QACf,MAAMC,gBAAgB9B,cAAcpE,aAAaI,QAAQC,OAAO;QAChE,iEAAiE;QACjE,MAAM8F,aAAa1B,iBAAiB2B,IAAI;QACxC,MAAMC,eAAehC,mBAAmB+B,IAAI;QAC5C,MAAMpD,aAAaqB,mBAAmB+B,IAAI,IAAI3B,iBAAiB2B,IAAI,MAAM,EAAE;YACvEtD,YAAY,0FAA0F;QAC1G;QACA,wEAAwE;QACxE,wFAAwF;QACxF,IAAI,IAAIwD,IAAI,GAAGA,IAAI,GAAGA,IAAI;YACtB,qEAAqE;YACrE,MAAM5B,iBAAiBwB,iBAAiB7B,mBAAmBtC,IAAI,KAAK,KAAKsC,mBAAmBtC,IAAI,OAAO,EAAE,8FAA8F;aACtM;gBACGc;YACJ;YACA,8CAA8C;YAC9C,MAAM6B,iBAAiBwB,iBAAiBzB,iBAAiB1C,IAAI,KAAK3B,QAAQI,cAAc,CAAC;gBACrFsC;YACJ;QACJ;QACA,oEAAoE;QACpE,OAAO2B,iBAAiB2B,IAAI,OAAOD,cAAc9B,mBAAmB+B,IAAI,OAAOC;IACnF;IACA,MAAME,cAAc;QAChB,IAAIP,0BAA0B7F,eAAe;YACzCA,gBAAgB;YAChB0F;QACJ;IACJ;IACA,MAAM5E,SAASuF,IAAAA,kBAAQ,EAACD;IACxB,MAAME,UAAU,CAACC,mBAAmBC;QAChCxB,OAAOyB,MAAM,CAACxG,SAASuG;QACvBzG,YAAY;QACZiF,OAAO0B,MAAM,CAACjG,eAAekG,OAAO,CAAC,CAACvB,OAAOd,iBAAiBlD,OAAO,CAACgE,KAAKT,EAAE;QAC7E9E,YAAY0G;QACZ5F,eAAe2F,OAAO,CAACzG;IAC3B;IACA,MAAM+G,aAAa;QACf7G,YAAY;QACZJ,UAAUmG,KAAK;QACfnF,eAAeiG,UAAU;IAC7B;IACA,MAAM1E,UAAU,CAACkD;QACb,IAAI3E,aAAa,CAAC2E,KAAKT,EAAE,CAAC,EAAE;YACxB;QACJ;QACAlE,aAAa,CAAC2E,KAAKT,EAAE,CAAC,GAAGS;QACzB,mEAAmE;QACnE,IAAIrF,WAAW;YACX,sDAAsD;YACtD,uEAAuE;YACvE,8CAA8C;YAC9CC,gBAAgB;YAChBsE,iBAAiBlD,OAAO,CAACgE,KAAKT,EAAE;QACpC;QACA,IAAIS,KAAK3D,OAAO,EAAE;YACdmB,aAAaV,OAAO,CAACkD,KAAKT,EAAE,EAAES,KAAK3D,OAAO;YAC1C2D,KAAK7B,OAAO,CAACkC,YAAY,CAACoB,2BAAmB,EAAEzB,KAAK3D,OAAO;QAC/D;QACAX;IACJ;IACA,MAAMgG,kBAAkB,CAAClD;QACrB9D,eAAe8D;IACnB;IACA,MAAMmD,aAAa,CAACC;QAChB,IAAI,CAACA,QAAQvF,OAAO,IAAIf,gBAAgB,CAACsG,QAAQvF,OAAO,CAAC,EAAE;YACvD;QACJ;QACAuF,QAAQzD,OAAO,CAACkC,YAAY,CAACoB,2BAAmB,EAAEG,QAAQvF,OAAO;QACjEf,gBAAgB,CAACsG,QAAQvF,OAAO,CAAC,GAAGuF;IACxC;IACA,MAAMC,qBAAqB;QACvBnH,eAAeS;IACnB;IACA,MAAM2G,gBAAgB,CAACzF;QACnB,IAAI,CAACf,gBAAgB,CAACe,QAAQ,EAAE;YAC5B;QACJ;QACA,MAAMuF,UAAUtG,gBAAgB,CAACe,QAAQ;QACzC,IAAIuF,QAAQvF,OAAO,EAAE;YACjB,OAAOf,gBAAgB,CAACe,QAAQ;YAChCuF,QAAQzD,OAAO,CAACgC,eAAe,CAACsB,2BAAmB;QACvD;IACJ;IACA,MAAMrE,aAAa,CAACR;QAChB,IAAI,CAACvB,aAAa,CAACuB,OAAO,EAAE;YACxB;QACJ;QACA,MAAMoD,OAAO3E,aAAa,CAACuB,OAAO;QAClCsC,iBAAiB6C,MAAM,CAACnF;QACxBkC,mBAAmBiD,MAAM,CAACnF;QAC1B,IAAIoD,KAAK3D,OAAO,EAAE;YACdmB,aAAaJ,UAAU,CAAC4C,KAAKT,EAAE,EAAES,KAAK3D,OAAO;YAC7C2D,KAAK7B,OAAO,CAACgC,eAAe,CAACsB,2BAAmB;QACpD;QACAlH,UAAU8C,MAAM,CAAC2C,KAAK7B,OAAO;QAC7B,OAAO9C,aAAa,CAACuB,OAAO;QAC5BlB;IACJ;IACA,OAAO;QACHoB;QACA0E;QACAR;QACAE;QACA9D;QACA1B;QACAgG;QACAG;QACAF;QACAG;IACJ;AACJ"}